----------------------
The Flexx event system
----------------------

The event module provides a system for properties and events,
to let different components of an application react to each-other and
to user input.

In short:

* The :class:`Component <flexx.event.Component>` class provides a base class
  which can be subclassed to create the different components of an app.
* Each component has :class:`properties <flexx.event.Property>` to reflect
  the state of the component.
* Properties can only be mutated by :class:`actions <flexx.event.action>`.
  Calling (i.e. invoking) an action will not apply the action at once; actions
  are processed in batches.
* When properties are modified (i.e. the state is changed),
  corresponding :class:`reactions <flexx.event.reaction>`
  will be invoked. The reactions are processed when all pending actions
  are done. This means that during processing reactions, the state never changes,
  which is a great thing to rely on!
* Reactions can also react to events generated by :func:`emitters <flexx.event.emitter>`,
  such as mouse events.
* The :class:`event loop <flexx.event.Loop>` object is responsible for scheduling
  actions and reactions and can be used by the user to e.g. make a function be
  called later. It intergrates with Python's own asyncio loop.

The asynchronous nature of actions combined with the fact that the state does
not change during processing reactions, makes it easy to reason about
cause and effect. The information flows in one direction. This concept was
gratefully taken from modern frameworks such as React/Flux and Veux.

.. image:: https://docs.google.com/drawings/d/e/2PACX-1vSHp4iha6CTgjsQ52x77gn0hqQP4lZD-bcaVeCfRKhyMVtaLeuX5wpbgUGaIE0Sce_kBT9mqrfEgQxB/pub?w=503

One might suggest that the information flow is still circular, because there
is an arrow going from reactions to actions. This is true, but note that
actions invoked from reactions are not directly executed; they are pended and
will be executed only after all reactions are done.


Relation to other parts of Flexx
--------------------------------

This event system and its :class:`Component <flexx.event.Component>` class
form the basis for :class:`app.PyComponent <flexx.app.PyComponent>`,
:class:`app.JsComponent <flexx.app.JsComponent>` and the UI system
in ``flexx.ui``. It can be used in both Python and JavaScript and works exactly
the same in both languages.

Other than that, this is a generic event system that could drive any system
that is based on asyncio.

Event object
------------

An event is something that has occurred at a certain moment in time,
such as the mouse being pressed down or a property changing its value.
In Flexx, events are represented with dictionary objects that
provide information about the event (such as what button was pressed,
or the old and new value of a property). A custom :class:`Dict <flexx.event.Dict>`
class is used that inherits from ``dict`` but allows attribute access,
e.g. ``ev.button`` as an alternative to ``ev['button']``.

Each event object has at least two attributes: ``source``,
a reference to the Component object emitting the event, and ``type``, a string
indicating the type of the event.


The Component class
-------------------

The :class:`Component <flexx.event.Component>` class provides a base
class for objects that have properties, actions, reactions and emitters.
E.g. ``flexx.ui.Widget`` inherits from ``flexx.app.JsComponent``,
which inherits from ``flexx.event.Component``.


.. code-block:: python

    class MyObject(event.Component):
        ...  # attributes/properties/actions/reactions/emitters go here

        def init(self):
            super().init()
            ...


It is common to implement the ``init()`` method of the component class. It gets
automatically called by the component, at a moment when all properties have
been initialized, but no events have been emitted yet. This is a good time
to further initialize the component, and/or to instantiate sub components.
One rarely needs to implement the ``__init__()`` method.

When the ``init()`` is called, the component is the currently "active"
component, which can be used to e.g. descrive a hierarchy of objects, as is
done with widgets. It also implies that mutations are allowed and that actions
on the component itself have a direct effect (invoking actions of other
components is still asynchronous though).


Properties represent state
--------------------------

:class:`Properties <flexx.event.Property>` can be defined using one of
the several property classes. For example:

.. code-block:: python

    class MyObject(event.Component):

        foo = event.AnyProp(8, settable=True, doc='can have any value')
        bar = event.IntProp()

Properties accept one positional arguments to set the default value. If not
given, a sensible default value is used that depends on the type of property.
The ``foo`` property above is marked as settable, so that the class will have
a ``set_foo()`` action. Docs can be added too. Note that properties
are readonly: they can can only be mutated by actions.

Property values can be initialized when a component is created (also
non-settable properties):

.. code-block:: python

    c = MyComponent(foo=42)

One can also set the initial value of a property to a function object.
This creates an auto-reaction that sets the property, and makes it possible
to hook things up in a very concise manner. In the example below, the label
text will be automatically updated when the username property changes:

.. code-block:: python

    c = UiLabel(text=lambda: self.username)

An event is emitted every time that a property changes. This event has attributes
``old_value`` and ``new_value`` (except for in-place array mutations, as
explained below). At initialization, a component sends out an event for each property,
which has the same value for ``old_value`` and ``new_value``.

Component classes can also have :class:`Attributes <flexx.event.Attribute>`,
which are read-only (usually static) non-observable values (e.g. ``JsComponent.id``).


Actions can mutate properties
-----------------------------

:class:`Actions <flexx.event.action>` can be defined to mutate properties:

.. code-block:: python

    class MyObject(event.Component):

        foo = event.AnyProp(8, settable=True, doc='can have any value')
        bar = event.IntProp()

        @event.action
        def increase_bar(self):
            self._mutate_bar(self.bar + 1)
            # shorthand for self._mutate('bar', self.bar + 1)

Actions can have any number of (positional) arguments. Note that actions are
asynchronous, i.e. calling an action will not apply it immediately, unless it is
called from another action.

Since actions are asynchronous, their inner function should not return a value.
Invoking (i.e. calling) an action always returns the component itself, which
allows chainging action invokations, e.g. ``t.scale(3).translate(3, 4)``

Mutations are done via the :func:`_mutate <flexx.event.Component._mutate>` method,
or by the auto-generated ``_mutate_xx()`` methods.
Mutations can only be done from an action. Trying
to do so otherwise will result in an error. This may seem limiting at first,
but it greatly helps keeping it easy to reason about information flowing
through your application, even as it scales.


Mutations to array-like properties
----------------------------------

The above shows the simple and most common use of mutations. For list
properties, mutations can also be done in-place:

.. code-block:: python

    class MyObject(event.Component):

        items = event.ListProp()

        def add_item(self, item):
            self._mutate_items([item], 'insert', len(self.items))

This allows more fine-grained control over state updates, which can also
be handled by reactions in much more efficient ways. The types of mutations are
'set' (the default), 'insert', 'replace', and 'remove'. In the latter, the
provided value is the number of elements to remove. For the others it must
be a list of elements to set/insert/replace at the specified index.


Emitters create events
----------------------

:func:`Emitters <flexx.event.emitter>` make it easy to generate events.
Similar to actions, they are created with a decorator.

.. code-block:: python

    class MyObject(event.Component):

        @event.emitter
        def pointer_down(self, js_event):
            ''' Event emitted when the mouse/touchpad/screen is pressed.
            '''
            return dict(button=js_event.button)

Emitters can have any number of arguments and should return a dictionary,
which will get emitted as an event, with the event type matching the name
of the emitter.

Note that stricly speaking emitters are not necessary as ``Component.emit()``
can be used to generate an event. However, they provide a mechanism to
generate an event based on certain input data, and also document the
events that a component may emit.

