"""
Definition of the Asset class to represent JS and CSS assets, and a derived
class used as a container for one or more JSModule classes.
"""

import sys
from urllib.request import urlopen

from . import logger

# The pyscript package does not deal with license headers,
# we add them to our assets here.
HEADER = 'Autogenerated code from Flexx. Code Subject to the BSD-2-clause license.'
HEADER = '/* %s */\n\n' % HEADER


def solve_dependencies(things, warn_missing=False):
    """ Given a list of things, which each have a ``name`` and ``deps``
    attribute, return a new list sorted to meet dependencies.
    """
    assert isinstance(things, list)
    names = [thing.name for thing in things]
    thingmap = dict([(n, t) for n, t in zip(names, things)])
    
    for index in range(len(names)):
        seen_names = set()
        while True:
            # Get thing name on this position, check if its new
            name = names[index]
            if name in seen_names:
                raise RuntimeError('Detected circular dependency!')
            seen_names.add(name)
            # Move deps in front of us if necessary
            for dep in thingmap[name].deps:
                if dep not in names:
                    if warn_missing:
                        logger.warn('%r has missing dependency %r' % (name, dep))
                else:
                    j = names.index(dep)
                    if j > index:
                        names.insert(index, names.pop(j))
                        break  # do this index again; the dep we just moved
            else:
                break  # no changes, move to next index
    return [thingmap[name] for name in names]

# todo: minification ...

class Asset:
    """ Class to represent an asset (JS or CSS) to be included on the page.
    
    By creating or importing an asset into a module that defines a Model/Widget
    subclass, the asset is automatically detected by Flexx. When detected, it
    will be loaded on the page, unless its a lazy asset, in which case the
    asset is only included on the page if the module is actually used.
    
    Parameters:
        name (str): the asset name, e.g. 'foo.js' or 'bar.css'. Can contain
            slashes to emulate a file system. e.g. 'spam/foo.js'. If this
            is a uri, then this is a "remote" asset (the client loads
            the asset from the uri).
        source (str, None): the source code for this asset.
            If this is a uri, the served loads the source from there (the
            client loads the asset from the Flexx server as usual).
        lazy (bool, func, optional): If True, the asset is loaded on the page
            *after* the module assets, and only if the module that its in is
            actually used. If it is a function, it will be called to
            produce the source when it is needed. This allows defining assets
            without causing side effects when they're not used.
    
    Note: a uri is a string starting with 'http://', 'https://' or 'file://'.
    The ``app.export()`` method provides control over how remote assets are
    handled.
    
    """
    
    _counter = 0
    
    def __init__(self, name, source=None, lazy=None):
        
        # Handle name
        if name is None:
            raise TypeError('Assets name must be given (str).')
        if not isinstance(name, str):
            raise TypeError('Asset name must be str.')
        if not name.lower().endswith(('.js', '.css')):
            raise ValueError('Asset name must end in .js or .css.')
        self._name = name
        
        Asset._counter += 1  # so we can sort assets by their instantiation order
        self.i = Asset._counter
        
        # Handle lazy
        if callable(lazy):
            self._lazy = lazy
            source = ''
        else:
            self._lazy = bool(lazy)
        
        # Handle source
        if source is None:
            pass
        elif not isinstance(source, str):
            raise TypeError('Asset source must be str.')
        self._source = source
        
        # Remote source?
        self._remote = None
        uri_starts = 'http://', 'https://', 'file://'
        if name.startswith(uri_starts):
            self._remote = name
            self._name = name.replace('\\', '/').split('/')[-1]
            if self._source is not None:
                raise TypeError('Remote assets cannot have a source: %s' % name)
        elif source is None:
            raise TypeError('Assets must have a source (except remote assets).')
        
        
    def __repr__(self):
        return '<%s %r at 0x%0x>' % (self.__class__.__name__, self._name, id(self))
    
    @property
    def name(self):
        """ The (file) name of this asset.
        """
        return self._name
    
    @property
    def source(self):
        """ The string source for this asset, or None if its a remote asset.
        """
        return self._source
    
    @property
    def remote(self):
        """ If the asset is remote (client will load it from elsewhere), then 
        this is the corresponding URI. Otherwise this is None.
        """
        return self._remote
    
    @property
    def lazy(self):
        """ Whether this is a lazy asset.
        """
        return bool(self._lazy)
    
    def to_html(self, path='{}', link=2):
        """ Get HTML element tag to include in the document.
        
        Parameters:
            path (str): the path of this asset, in which '{}' can be used as
                a placeholder for the asset name.
            link (int): whether to link to this asset. If 0, the asset is
                embedded. If 1, the asset is linked (and served by our server
                as a separate file). If 2 (default) remote assets remain remote.
        """
        path = path.replace('{}', self.name)
        
        if self.name.lower().endswith('.js'):
            if not link:
                return "<script id='%s'>%s</script>" % (self.name, self.to_string())
            elif link >= 2 and self.remote:
                return "<script src='%s' id='%s'></script>" % (self.remote, self.name)
            else:
                return "<script src='%s' id='%s'></script>" % (path, self.name)
        elif self.name.lower().endswith('.css'):
            if not link:
                return "<style id='%s'>%s</style>" % (self.name, self.to_string())
            elif link >= 2 and self.remote:
                t = "<link rel='stylesheet' type='text/css' href='%s' id='%s' />"
                return t % (self.remote, self.name)
            else:
                t = "<link rel='stylesheet' type='text/css' href='%s' id='%s' />"
                return t % (path, self.name)
        else:  # pragma: no cover
            raise NameError('Assets must be .js or .css')
    
    def to_string(self):
        """ Get the string code for this asset. Even for remote assets.
        """
        if self._lazy and callable(self._lazy):
            self._source = self._lazy()
            if not isinstance(self._source, str):
                t = 'Lazy function of asset %r did not return a str, but a %s.'
                raise ValueError(t % (self.name, self._source.__class__.__name__))
            self._lazy = True
        if self.remote:
            if not hasattr(self, '_remote_source_cache'):
                uri = self.remote
                if uri.startswith(('http://', 'https://')):
                    source = urlopen(uri, timeout=5.0).read().decode()
                elif uri.startswith('file://'):
                    fname = uri.split('//', 1)[1]
                    if sys.platform.startswith('win'):
                        fname = fname.lstrip('/')
                    source = open(fname, 'rb').read().decode()
                else:
                    assert False  # should not happen
                self._remote_source_cache = source
            return self._remote_source_cache
        else:
            return self._source


class Bundle(Asset):
    """ A bundle is an asset that represents a collection of JSModule objects.
    It is a rather thin wrapper, and can therefore very easily be used to
    represent modules at different levels in the module tree.
    """
    
    def __init__(self, name):
        super().__init__(name, '')
        self._module_name = name.rsplit('.', 1)[0].split('-')[0]
        self._modules = []
        self._deps = set()
        self._need_sort = False
    
    def __repr__(self):
        return '<%s %r with %i modules at 0x%0x>' % (self.__class__.__name__,
                                                     self._name,
                                                     len(self._modules),
                                                     id(self))
    
    def add_module(self, m):
        """ Add a module to the bundle. This will (lazily) invoke a
        sort of the list of moduldes, and add dependencies to other
        bundles, so that bundles themselves can be sorted.
        """
        
        # Check if module belongs here
        if not m.name.startswith(self._module_name):
            raise ValueError('Module %s does not belong in bundle %s.' %
                             (m.name, self.name))
        
        # Add module
        self._modules.append(m)
        self._need_sort = True
        
        # Add deps for this module
        deps = set()
        for dep in m.deps:
            while '.' in dep:
                deps.add(dep)
                dep = dep.rsplit('.', 1)[0]
            deps.add(dep)
        
        # Clear deps that are represented by this bundle
        ext = '.' + self.name.rsplit('.')[-1]
        for dep in deps:
            if not (dep.startswith(self._module_name) or
                    self._module_name.startswith(dep + '.')):
                self._deps.add(dep + ext)
   
    @property
    def modules(self):
        """ The list of modules, sorted by name and dependencies.
        """
        if self._need_sort:
            f = lambda m: m.name
            self._modules = solve_dependencies(sorted(self._modules, key=f))
        return tuple(self._modules)
    
    @property
    def deps(self):
        """ The set of dependencies for this bundle, expressed in module names.
        """
        return self._deps
    
    def to_string(self):
        # Concatenate code strings and add TOC. Module objects do/cache the work.
        isjs = self.name.lower().endswith('.js')
        toc = []
        source = []
        for m in self.modules:
            s = m.get_js() if isjs else m.get_css()
            toc.append('- ' + m.name)
            source.append('/* ' + (' %s ' % m.name).center(70, '=') + '*/')
            source.append(s)
        source.insert(0, '/* Bundle contents:\n' + '\n'.join(toc) + '\n*/\n')
        source.insert(0, HEADER)
        return '\n\n'.join(source)
