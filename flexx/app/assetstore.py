"""
Asset store.

The purpose of these classes is simple: they must provide the assets
(JavaScript files, CSS files, images, etc.) needed by the applications.

Assets are global, which makes certain things (e.g. exporting a bunch
of apps to the same directory) very simple.

Naturally, different sessions may need different assets with the same
name. Therefore the SessionAssets class provides a way to manage assets
with name mangling.
    
Groups of Model classes can be added as a CSS and JS asset using
``assets.create_module_assets()``, which will select all Model classes
present in the given Python module. Classes used by the session that
are not provided via such a module asset will be added to the index.
"""

import os
import sys
import json
import time
import random
import hashlib
from urllib.request import urlopen
from collections import OrderedDict

from .model import Model, get_model_classes
from ..pyscript import py2js
from . import logger


INDEX = """<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <title>Flexx UI</title>

ASSET-LINK-HOOK

</head>

<body id='body'>

ASSET-CONTENT-HOOK

</body>
</html>
"""

LOADER = """
if (typeof window === 'undefined' && typeof module == 'object') {
    global.window = global; // https://github.com/nodejs/node/pull/1838
    window.is_node = true;
}
window._flexx_modules = {};
window.define = function (name, deps, factory) {
    /* Very simple variant of UMD loader */
    if (typeof define === 'function' && define.amd) {
        return define(name, deps, factory);
    }
    dep_vals = [];
    for (var i=0; i<deps.length; i++) {
        if (_flexx_modules[deps[i]] === undefined) {
            throw Error('Unknown dependency: ' + deps[i]);
        }
        dep_vals.push(_flexx_modules[deps[i]]);
    }
    _flexx_modules[name] = factory.apply(null, dep_vals);
};
window.require = function(name) {
    return _flexx_modules[name];
}
"""

RESET = """
/*! normalize.css v3.0.3 | MIT License | github.com/necolas/normalize.css */
html
{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
body{margin:0}
article,aside,details,figcaption,figure,footer,header,hgroup,main,menu,nav,
section,summary{display:block}
audio,canvas,progress,video{display:inline-block;vertical-align:baseline}
audio:not([controls]){display:none;height:0}
[hidden],template{display:none}
a{background-color:transparent}
a:active,a:hover{outline:0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
h1{font-size:2em;margin:.67em 0}
mark{background:#ff0;color:#000}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-0.5em}
sub{bottom:-0.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:1em 40px}
hr{box-sizing:content-box;height:0}
pre{overflow:auto}
code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}
button,input,optgroup,select,textarea{color:inherit;font:inherit;margin:0}
button{overflow:visible}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]
{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
input{line-height:normal}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
input[type="number"]::-webkit-inner-spin-button,
input[type="number"]::-webkit-outer-spin-button{height:auto}
input[type="search"]{-webkit-appearance:textfield;box-sizing:content-box}
input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}
fieldset{border:1px solid #c0c0c0;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
textarea{overflow:auto}
optgroup{font-weight:bold}
table{border-collapse:collapse;border-spacing:0}
td,th{padding:0}
"""

HEADER = '/* Autogenerated code from Flexx. Code Subject to the BSD-2-clause license.*/'


reprs = json.dumps


def modname_startswith(x, y):
    return (x + '.').startswith(y + '.')


def create_css_and_js_from_model_classes(classes, css='', js=''):
    # Collect CSS and JS, and filter out empty ones
    css, js = [css], [js]
    for cls in classes:
        css.append(cls.CSS)  # the CSS is '' if not specified for that class
        js.append(cls.JS.CODE)
    css = [i for i in css if i.strip()]
    js = [i for i in js if i.strip()]
    if css:
        css.insert(0, HEADER)
    if js:
        js.insert(0, '"use strict";')
        js.insert(0, HEADER)
    return '\n\n'.join(css) or '\n', '\n\n'.join(js) or '\n'


# Use the system PRNG for session id generation (if possible)
# NOTE: secure random string generation implementation is adapted
#       from the Django project. 

def get_random_string(length=24, allowed_chars=None):
    """ Produce a securely generated random string.
    
    With a length of 12 with the a-z, A-Z, 0-9 character set returns
    a 71-bit value. log_2((26+26+10)^12) =~ 71 bits
    """
    allowed_chars = allowed_chars or ('abcdefghijklmnopqrstuvwxyz' +
                                      'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789')
    try:
        srandom = random.SystemRandom()
    except NotImplementedError:  # pragma: no cover
        srandom = random
        logger.warn('Falling back to less secure Mersenne Twister random string.')
        bogus = "%s%s%s" % (random.getstate(), time.time(), 'sdkhfbsdkfbsdbhf')
        random.seed(hashlib.sha256(bogus.encode()).digest())

    return ''.join(srandom.choice(allowed_chars) for i in range(length))


# todo: what if we constrained the scope of flexx.app and above to browsers, e.g. no node? I wonder if this code would get simpler. Also clientcore et al. can assume the presence of the window object.


class Asset:
    """ Abstract class to represent an asset (JS or CSS) to be included
    on the page, and can have dependencies on other assets.
    
    Parameters:
        name (str): the asset name, e.g. 'foo.css'.
        deps (list): names of assets that this asset depends on.
        code (str): the code for this asset. Multiple pieces of code can be
            given, and can also be given in the form of a function or class.
            See the docs of ``code`` for details.
    """
    def __init__(self, name, deps, *code):
        if not name.lower().endswith(('.js', '.css')):
            raise ValueError('Asset is only for .js and .css assets.')
        self._name = str(name)
        self._deps = list(deps)  # for elements in code that are modules, the deps are added last-minute
        self._code = list(code)  # elements in code can be Modules, or anythig that can be str-ed
        self._cache = None
    
    def __repr__(self):
        return '<%s %r at 0x%0x>' % (self.__class__.__name__, self._name, id(self))
        
    @property
    def name(self):
        """ The (file) name of this asset.
        """
        return self._name
    
    @property
    def deps(self):
        """ List of dependencies for this JS/CSS asset.
        """
        return tuple(self._deps)
    
    # todo: silly, use append_code and append_dep to control cache etc. or error
    @property
    def code(self):
        """ The list of code pieces. Each code piece can be:
        
        * A string of JS/CSS code.
        * A filename or uri (start with "file://", "http://" or "https://"):
          the code is (down)loaded on the server. Use ``RemoteAsset`` to
          create an asset for which the client loads the code.
        * A subclass of ``Model``: the corresponding JS/CSS is extracted.
        * Any other Python function ot class: JS is generated via PyScript.
        """
        return tuple(self._code)
    
    def to_html(self, embed=False):
        """ Get HTML element tag to include in the document.
        """
        if self.name.lower().endswith('.js'):
            if embed:
                return '<script>\n' + self.to_string() + '\n</script>'
            else:
                return "<script src=%r></script>" % self.name
        elif self.name.lower().endswith('.css'):
            if embed:
                code, _ = self._get_code_and_names()
                return '<style>\n' + self.to_string() + '\n</style>'
            else:
                return "<link rel='stylesheet' type='text/css' href=%r />" % self.name
        else:  # pragma: no cover
            raise NameError('Assets must be .js or .css')
    
    def to_string(self):
        """ Get the string code provided by this asset. This is what
        gets served to the client.
        """
        if self._cache is None:
            code, names = self._get_code_and_names()
            self._cache = '\n\n'.join(code)
        return self._cache
    
    def _get_code_and_names(self):
        # todo: add license header and strict mode?
        code = []
        names = []
        for ob in self.code:
            c, name = self._convert_to_code(ob)
            if c:
                code.append(c)
                if name:
                    names.append(name)
        return code, names
    
    def _convert_to_code(self, ob):
        """ Convert object to JS/CSS.
        """
        isjs = self.name.lower().endswith('.js')
        name = None
        
        if isinstance(ob, str):
            c = self._handle_uri(ob)
        elif isinstance(ob, type) and issubclass(ob, Model):
            name = ob.__name__
            c = ob.JS.CODE if isjs else ob.CSS
        elif isjs and callable(ob):
            try:
                c = py2js(ob)
            except Exception as err:
                raise ValueError('Asset %r cannot convert %r to JS:\n%s' %
                                 (self.name, ob, str(err)))
            name = ob.__name__
        else:
            raise ValueError('Asset %r cannot convert object %r to CSS.' %
                             (ob, self.name.split('.')[0].upper()))
        return c.strip(), name
    
    def _handle_uri(self, s):
        if s.startswith(('http://', 'https://')):
            return urlopen(s, timeout=5.0).read().decode()
        elif s.startswith('file://'):
            return open(s.split('//', 1)[1], 'rb').read().decode()
        else:
            return s


class EmbeddedAsset(Asset):
    """ An asset that is always embedded on the page.
    """
    
    def to_html(self, embed=False):
        return super().to_html(True).replace('\n', '')


class RemoteAsset(Asset):
    """ An asset that represents a remote resource (e.g. an asset from a CDN).
    When exporting an app, the code will be embedded, so that no
    internet connection is required to use the app.
    
    Parameters:
        name (str): the asset name, e.g. 'foo.css'.
        deps (list): names of assets that this asset depends on.
        url (str): the asset URL.
    """
    
    def __init__(self, name, deps, url):
        if not url.startswith(('http://', 'https://', 'file://')):
            raise ValueError('RemoteAsset url must start with '
                             '"http://", "https://", or "file://".')
        super().__init__(name, deps, url)
    
    @property
    def url(self):
        """ The remote asset URL.
        """
        return self._code[0]
    
    def to_html(self, embed=False):
        if embed:
            return super().to_html(True)
        
        if self.name.lower().endswith('.js'):
            return "<script src=%r></script>" % self.url
        elif self.name.lower().endswith('.css'):
            return "<link rel='stylesheet' type='text/css' href=%r />" % self.url
        else:  # pragma: no cover
            raise NameError('Assets must be .js or .css')


class ModuleAsset(Asset):
    """ An asset to represent JS code wrapped in a module.
    
    Parameters:
        name (str): the asset name, e.g. 'bar.js'.
        deps (list): names of assets that this asset depends on. Dependencies
            written in the form "foo.js as foo" (i.e. using "as") are imports
            in the module and can be used inside the module under that name.
            The PyScript std is automatically added to the deps.
        exports (list): the names that this JS module should export.
        code (str): the code for this asset. Multiple pieces of code can be
            given. See the docs of ``code`` for details.
    """
    
    def __init__(self, name, deps, exports, *code):
        if not name.lower().endswith('.js'):
            raise ValueError('ModuleAsset is only for .js assets.')
        if not isinstance(exports, list):
            raise ValueError('ModuleAsset.exports must be a list.')
        short_deps = [d.split(' as ')[0] for d in deps]
        super().__init__(name, short_deps, *code)
        self._imports = [d for d in deps if ' as ' in d]
        self._exports = list(exports)
    
    @property
    def exports(self):
        """ List of names that this JS module should export. Is
        auto-populated with the names of classes provided in the
        code list.
        """
        return tuple(self._exports)
    
    def to_string(self):
        # Use PyScript JSModule to wrap our code
        if self._cache is None:
            code, names = self._get_code_and_names()
            s = '\n\n'.join(code)
            from ..pyscript.stdlib import JSModule, FUNCTION_PREFIX, METHOD_PREFIX
            s = s.replace(FUNCTION_PREFIX, 'py_.f_').replace(METHOD_PREFIX, 'py_.m_')
            m = JSModule(self.name, s,
                         ['pyscript-std.py as py_'] + self._imports,
                         names + self._exports)
            self._cache = m.saves()
        return self._cache


class AssetStore:
    """ Global provider of client assets (CSS, JavaScript, images, etc.).
    
    Assets are global to the process via the AssetStore instance at
    ``flexx.app.assets``. An asset must be "used" at each ``Session``
    instance where it ought to be loaded. The session can also be used
    to load unique (per session, name mangled) assets.
    """
    
    def __init__(self):
        self._assets = OrderedDict()
        self._data = {}
        self.add_asset(Asset('reset.css', [], RESET))
        self.add_asset(Asset('flexx-loader.js', [], LOADER))
    
    def __repr__(self):
        names1 = ', '.join([repr(name) for name in self._assets])
        names2 = ', '.join([repr(name) for name in self._data])
        return '<AssetStore with assets: %s, and data %s>' % (names1, names2)
    
    def get_asset(self, name):
        """ Get the asset instance corresponding to the given name or None
        if it not known.
        """
        if not name.lower().endswith(('.js', '.css')):
            raise ValueError('Asset names always end in .js or .css')
        return self._assets.get(name, None)
    
    def get_data(self, name):
        """ Get the data (as bytes) corresponding to the given name or None
        if it not known.
        """
        return self._data.get(name, None)
    
    def get_asset_names(self):
        """ Get a list of all asset names.
        """
        return list(self._assets.keys())
    
    def get_data_names(self):
        """ Get a list of all data names.
        """
        return list(self._data.keys())
    
    def add_data(self, name, data):
        """ Add data to serve to the client (e.g. images). It is an
        error to add data with a name that is already registered.
        
        Parameters:
            name (str): the name of the data, e.g. 'icon.png'. 
            data (bytes): the data blob.
        """
        if not isinstance(name, str):
            raise ValueError('AssetStore.add_data() name must be a str.')
        if name in self._data:
            raise ValueError('AssetStore.add_data() got existing name %r.' % name)
        if not isinstance(data, bytes):
            raise ValueError('AssetStore.add_data() data must be a bytes.')
        self._data[name] = data
    
    def add_asset(self, *assets):
        """ Add one or more assets (JS or CSS) to serve the client. It is an
        error to add an asset with a name that is already registered.
        
        Parameters:
            assets (Asset): The asset to add.
        """
        for asset in assets:
            if not isinstance(asset, Asset):
                raise ValueError('AssetStorr.add_asset() needs an Asset instance.')
            if asset.name in self._assets:
                raise ValueError('Asset %r is already set.' % asset.name)
            self._assets[asset.name] = asset
    
    def get_asset_for_class(self, cls):
        """ Get the asset that provides the given Python class.
        """
        for asset in self._assets.values():
            if cls in asset.code:
                return asset
        return None
    
    def get_module_classes(self, module_name):
        """ Get the Model classes corrsesponding to the given module name
        and that are not already provided by an asset.
        """
        # Get classes
        classes = list()
        for cls in get_model_classes():
            if modname_startswith(cls.__module__, module_name):
                if self.get_asset_for_class(cls) is None:
                    classes.append(cls)
        return classes
    
    # todo: test this
    def export(self, dirname):
        """ Write all assets to the given directory.
        """
        # Normalize and check
        if dirname.startswith('~'):  # pragma: no cover
            dirname = os.path.expanduser(dirname)
        if not os.path.isdir(dirname):
            raise ValueError('dirname %r for export is not a directory.' % dirname)
        # Export all assets
        for fname in self.get_asset_names():
            if not fname.startswith('index-'):
                with open(os.path.join(dirname, fname), 'wb') as f:
                    f.write(self.get_asset(fname).tobytes())

# Our singleton asset store
assets = AssetStore()


class SessionAssets:
    """ Provider for assets for a specific session. Inherited by Session.
    
    Assets included on the document consist of the page assets
    registered on the session, plus the (global) page assets that these
    depend on.
    """
    
    def __init__(self, store=None):  # Allow custom store for testing
        self._store = store if (store is not None) else assets
        assert isinstance(self._store, AssetStore)
        
        self._id = get_random_string()
        self._app_name = ''
        
        # Keep track of all assets for this session. Assets that are provided
        # by the asset store have a value of None.
        self._assets = OrderedDict()
        # Data for this session (in addition to the data provided by the store)
        self._data = {}
        # Whether the page has been served already
        self._served = False
        # Cache what classes we know (for performance)
        self._known_classes = set()
        # Model classes that are not in an asset/module
        self._extra_model_classes = []
    
    @property
    def id(self):
        """ The unique identifier of this session.
        """
        return self._id
    
    def get_asset_names(self):
        """ Get a list of names of the assets used by this session, in
        the order that they were added.
        """
        return list(self._assets.keys())  # Note: order matters
    
    def get_data_names(self):
        """ Get a list of names of the data provided by this session, in
        the order that they were added.
        """
        return list(self._data.keys())  # Note: order matters
    
    def _inject_asset_dynamically(self, asset):
        """ Load an asset in a running session.
        """
        logger.debug('Dynamically loading asset %r' % asset.name)
        
        # In notebook?
        from .session import manager  # noqa - avoid circular import
        is_interactive = self is manager.get_default_session()  # e.g. in notebook
        in_notebook = is_interactive and getattr(self, 'init_notebook_done', False)
        
        if in_notebook:
            # Load using IPython constructs
            from IPython.display import display, HTML
            if asset.name.lower().endswith('.js'):
                display(HTML("<script>%s</script>" % asset.to_string()))
            else:
                display(HTML("<style>%s</style>" % asset.to_string()))
        else:
            # Load using Flexx construct
            suffix = asset.name.split('.')[-1].upper()
            self._send_command('DEFINE-%s %s' % (suffix, asset.to_string()))
    
    def get_asset(self, name):
        """ Get the asset corresponding to the given name. This can be
        an asset local to the session, or a global asset that this session
        is using. Returns None if asset by that name is unknown.
        """
        if not name.lower().endswith(('.js', '.css')):
            raise ValueError('Asset names always end in .js or .css')
        asset = self._assets.get(name, None)
        if asset is None:
            asset = self._store.get_asset(name)
        return asset
    
    def get_data(self, name):
        """ Get the data corresponding to the given name. This can be
        data local to the session, or global data. Returns None if data
        by that name is unknown.
        """
        data = self._data.get(name, None)
        if data is None:
            data = self._store.get_data(name)
        return data
    
    def use_asset(self, asset):  # -> asset must already exist
        """ Use the given asset in this session. The given asset can
        also be the name of an asset in the asset store. It is safe to
        call this method with an already registered asset.
        """
        # Get the actual asset instance
        if isinstance(asset, str):
            asset = self._store.get_asset(asset)
            if asset is None:
                raise ValueError('AssetStore.add_asset() got unknown asset name.')
        if not isinstance(asset, Asset):
            raise ValueError('Session.use_asset() needs str or Asset.')
        
        # Register or load asset, if necessary
        if asset.name in self._assets:
            cur_asset = self._assets[asset.name]
            if not (cur_asset is None or cur_asset is asset):
                raise ValueError('Cannot register asset under an existing asset name.')
        elif self._served:
            self._inject_asset_dynamically(asset)
        elif asset is self._store.get_asset(asset.name):
            self._assets[asset.name] = None  # None means that asset is global
        else:
            self._assets[asset.name] = asset
    
    def use_data(self, name, data):  # todo: add option to clear data after its loaded?
        """ Add data to serve to the client (e.g. images), specific to this
        session.
        
        Parameters:
            name (str): the name of the data, e.g. 'icon.png'. If data has
                already been set on this name, it is overwritten.
            data (bytes): the data blob.
        """
        if not isinstance(name, str):
            raise ValueError('Session.add_data() name must be a str.')
        if name in self._data:
            raise ValueError('Session.add_data() got existing name %r.' % name)
        if not isinstance(data, bytes):
            raise ValueError('Session.add_data() data must be a bytes.')
        self._data[name] = data
    
    def register_model_class(self, cls):
        """ Ensure that the client knows the given class. A class can
        already be defined via a module asset, or we can add it to a
        pending list if the page has not been served yet. Otherwise it
        needs to be defined dynamically.
        """
        if not (isinstance(cls, type) and issubclass(cls, Model)):
            raise ValueError('Not a Model class')
        
        # Early exit if we know the class already
        if cls in self._known_classes:
            return
        
        # Make sure the base classes are registered first
        for cls2 in cls.mro()[1:]:
            if not issubclass(cls2, Model):  # True if cls2 is *the* Model class
                break
            if cls2 not in self._known_classes:
                self.register_model_class(cls2)
        
        # Make sure that no two models have the same name, or we get problems
        # that are difficult to debug. Unless classes are defined in the notebook.
        same_name = [c for c in self._known_classes if c.__name__ == cls.__name__]
        if same_name:
            from .session import manager  # noqa - avoid circular import
            same_name.append(cls)
            is_interactive = self is manager.get_default_session()  # e.g. in notebook
            is_dynamic_cls = not any([self._store.get_asset_for_class(c)
                                      for c in same_name])
            if not (is_interactive and is_dynamic_cls):
                raise RuntimeError('Cannot have multiple Model classes with the same '
                                   'name unless using interactive session and the '
                                   'classes are dynamically defined: %r' % same_name)
        
        logger.debug('Registering Model class %r' % cls.__name__)
        self._known_classes.add(cls)
        
        # Check if cls is covered by our assets
        asset_js = self._store.get_asset_for_class(cls)
        asset_css = None
        if asset_js:
            asset_css = self._store.get_asset(asset_js.name[:-2] + 'css')
        
        if asset_js:
            # cls is present in a module, add corresponding asset (overwrite ok)
            for asset in [asset_js, asset_css]:
                if asset and asset.name not in self._assets:
                    if self._served:
                        self._inject_asset_dynamically(asset)
                    else:
                        self._assets[asset.name] = None
        elif not self._served:
            # Remember cls, will be served in the index
            self._extra_model_classes.append(cls)
        else:
            # Define class dynamically - assuming we're a session subclass ...
            for asset in [Asset(cls.__name__ + '.js', [], cls.JS.CODE), 
                          Asset(cls.__name__ + '.css', [], cls.CSS)]:
                if asset.code[0].strip():
                    self._inject_asset_dynamically(asset)
    
    def get_assets_in_order(self, css_reset=False):
        """ Get two lists containing the JS assets and CSS assets,
        respectively. The assets contain all assets in use and their
        dependencies. The order is based on the dependency resolution
        and the order in which assets were registered via
        ``use_asset()``. Special assets are added, such as the CSS reset,
        the JS loader, and CSS and JS for classes not defined in a module.
        """
        # todo: test incorrect order; loader should be able to handle it for JS
        
        def collect_dependencies(asset, asset_dict):
            for dep in asset.deps:
                if dep in asset_dict:
                    pass  # already in list
                elif dep in self._store._assets:
                    a = self._store._assets[dep]
                    asset_dict[a.name] = a
                    collect_dependencies(a, asset_dict)
                else:
                    unknown_deps.append(dep)
                    logger.warn('Asset %r has unfulfilled dependency %r' %
                                (asset.name, dep))
        
        def flatten_tree(asset_list, asset_dict):
            for index in range(len(asset_list)):
                seen_names = []
                cur_asset_list = asset_list.copy()
                while True:
                    # Get asset name on this position, check if its new
                    name = asset_list[index]
                    if name in seen_names:
                        raise RuntimeError('Detected circular dependency in assets!')
                    seen_names.append(name)
                    # Move deps in front of us if necessary
                    for dep in asset_dict[name].deps:
                        if dep not in unknown_deps:
                            j = asset_list.index(dep)
                            if j > index:
                                asset_list.insert(index, asset_list.pop(j))
                                break  # do this index again; the dep we just moved
                    else:
                        break  # no changes, move to next index
        
        # Collect initial assets for this session
        js_assets, css_assets = OrderedDict(), OrderedDict()
        for name in self._assets.keys():
            asset = self.get_asset(name)
            if asset.name.lower().endswith('.js'):
                js_assets[asset.name] = asset
            else:
                css_assets[asset.name] = asset
        
        # Collect dependencies so that we have all assets that matter
        unknown_deps = []
        for asset in list(js_assets.values()):
            collect_dependencies(asset, js_assets)
        for asset in list(css_assets.values()):
            collect_dependencies(asset, css_assets)
        
        # Flatten the trees into flat lists
        js_assets2 = list(js_assets.keys())
        flatten_tree(js_assets2, js_assets)
        css_assets2 = list(css_assets.keys())
        flatten_tree(css_assets2, css_assets)
        js_assets = [js_assets[name] for name in js_assets2]
        css_assets = [css_assets[name] for name in css_assets2]
        
        # Prepend reset.css
        if css_reset:
            css_assets.insert(0, self.get_asset('reset.css'))
        
        # Prepend loader
        js_assets.insert(0, self.get_asset('flexx-loader.js'))
        t = 'var flexx = {app_name: "%s", session_id: "%s"};' % (self._app_name, self.id)
        js_assets.insert(0, EmbeddedAsset('flexx-init.js', [], t))
        
        # Append code for extra classes
        if self._extra_model_classes:
            js_assets.append(ModuleAsset('extra-classes.js', [], [],
                                         *self._extra_model_classes))
            css_assets.append(Asset('extra-classes.css', [],
                                    *self._extra_model_classes))
        
        return js_assets, css_assets
    
    def get_page(self, single=False):
        """ Get the string for the HTML page to render this session's app.
        """
        js_assets, css_assets = self.get_assets_in_order(True)
        return self._get_page(js_assets, css_assets, single)
    
    def get_page_for_export(self, commands, single=False):
        """ Get the string for an exported HTML page (to run without a server).
        """
        # Create lines to init app
        lines = []
        lines.append('flexx.is_exported = true;\n')  # todo: use session_id = 'exported'?
        lines.append('flexx.runExportedApp = function () {')
        lines.extend(['    flexx.command(%s);' % reprs(c) for c in commands])
        lines.append('};\n')
        # Compose - make it use a dummy session id
        id, self._id = self._id, 'exported'
        js_assets, css_assets = self.get_assets_in_order(True)
        self._id = id
        js_assets.append(Asset('flexx-export.js', [], '\n'.join(lines)))
        return self._get_page(js_assets, css_assets, single)
    
    def _get_page(self, js_assets, css_assets, single):
        """ Compose index page.
        """
        codes = []
        codes += [asset.to_html(single) for asset in css_assets]
        codes += ['']
        codes += [asset.to_html(single) for asset in js_assets]
        
        src = INDEX
        if single:
            src = src.replace('ASSET-LINK-HOOK', '')
            src = src.replace('ASSET-CONTENT-HOOK', '\n'.join(codes))
        else:
            codes = ['    ' + code for code in codes]
            src = src.replace('ASSET-LINK-HOOK', '\n'.join(codes))
            src = src.replace('ASSET-CONTENT-HOOK', '')
        
        return src
