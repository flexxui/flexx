"""
Asset store.

The purpose of these classes is simple: they must provide the assets
(JavaScript files, CSS files, images, etc.) needed by the applications.

Assets are global, which makes certain things (e.g. exporting a bunch
of apps to the same directory) very simple.

Naturally, different sessions may need different assets with the same
name. Therefore the SessionAssets class provides a way to manage assets
with name mangling.
    
Groups of Model classes can be added as a CSS and JS asset using
``assets.create_module_assets()``, which will select all Model classes
present in the given Python module. Classes used by the session that
are not provided via such a module asset will be added to the index.
"""

import os
import sys
import json
import time
import random
import hashlib
from urllib.request import urlopen
from collections import OrderedDict

from .model import Model, get_model_classes
from ..pyscript import py2js, create_js_module, get_all_std_names
from . import logger


INDEX = """<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <title>Flexx UI</title>

ASSET-LINK-HOOK

</head>

<body id='body'>

ASSET-CONTENT-HOOK

</body>
</html>
"""

LOADER = """
/*Flexx module loader. Licensed by BSD-2-clause.*/

(function(){

if (typeof window === 'undefined' && typeof module == 'object') {
    global.window = global; // https://github.com/nodejs/node/pull/1838
    window.is_node = true;
}
window._flexx_modules = {};
window.define = function (name, deps, factory) {
    /* Very simple variant of UMD loader */
    if (typeof define === 'function' && define.amd && !define.flexx) {
        return define(name, deps, factory);
    }
    dep_vals = [];
    for (var i=0; i<deps.length; i++) {
        if (_flexx_modules[deps[i]] === undefined) {
            throw Error('Unknown dependency: ' + deps[i]);
        }
        dep_vals.push(_flexx_modules[deps[i]]);
    }
    _flexx_modules[name] = factory.apply(null, dep_vals);
};
window.define.amd = true;  // Work nice with UMD
window.define.flexx = true;
window.require = function(name) {
    return _flexx_modules[name];
}

})();
"""

RESET = """
/*! normalize.css v3.0.3 | MIT License | github.com/necolas/normalize.css */
html
{font-family:sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}
body{margin:0}
article,aside,details,figcaption,figure,footer,header,hgroup,main,menu,nav,
section,summary{display:block}
audio,canvas,progress,video{display:inline-block;vertical-align:baseline}
audio:not([controls]){display:none;height:0}
[hidden],template{display:none}
a{background-color:transparent}
a:active,a:hover{outline:0}
abbr[title]{border-bottom:1px dotted}
b,strong{font-weight:bold}
dfn{font-style:italic}
h1{font-size:2em;margin:.67em 0}
mark{background:#ff0;color:#000}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-0.5em}
sub{bottom:-0.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:1em 40px}
hr{box-sizing:content-box;height:0}
pre{overflow:auto}
code,kbd,pre,samp{font-family:monospace,monospace;font-size:1em}
button,input,optgroup,select,textarea{color:inherit;font:inherit;margin:0}
button{overflow:visible}
button,select{text-transform:none}
button,html input[type="button"],input[type="reset"],input[type="submit"]
{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
input{line-height:normal}
input[type="checkbox"],input[type="radio"]{box-sizing:border-box;padding:0}
input[type="number"]::-webkit-inner-spin-button,
input[type="number"]::-webkit-outer-spin-button{height:auto}
input[type="search"]{-webkit-appearance:textfield;box-sizing:content-box}
input[type="search"]::-webkit-search-cancel-button,
input[type="search"]::-webkit-search-decoration{-webkit-appearance:none}
fieldset{border:1px solid #c0c0c0;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
textarea{overflow:auto}
optgroup{font-weight:bold}
table{border-collapse:collapse;border-spacing:0}
td,th{padding:0}
"""

# The pyscript package does not deal with license headers,
# we add them to our assets here.
HEADER = '/* Autogenerated code from Flexx. Code Subject to the BSD-2-clause license.*/'

reprs = json.dumps


def modname_startswith(x, y):
    return (x + '.').startswith(y + '.')


# Use the system PRNG for session id generation (if possible)
# NOTE: secure random string generation implementation is adapted
#       from the Django project. 

def get_random_string(length=24, allowed_chars=None):
    """ Produce a securely generated random string.
    
    With a length of 12 with the a-z, A-Z, 0-9 character set returns
    a 71-bit value. log_2((26+26+10)^12) =~ 71 bits
    """
    allowed_chars = allowed_chars or ('abcdefghijklmnopqrstuvwxyz' +
                                      'ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789')
    try:
        srandom = random.SystemRandom()
    except NotImplementedError:  # pragma: no cover
        srandom = random
        logger.warn('Falling back to less secure Mersenne Twister random string.')
        bogus = "%s%s%s" % (random.getstate(), time.time(), 'sdkhfbsdkfbsdbhf')
        random.seed(hashlib.sha256(bogus.encode()).digest())

    return ''.join(srandom.choice(allowed_chars) for i in range(length))


# todo: what if we constrained the scope of flexx.app and above to browsers, e.g. no node? I wonder if this code would get simpler. Also clientcore et al. can assume the presence of the window object.

# todo: minification ...

class Asset:
    """ Class to represent an asset (JS or CSS) to be included on the
    page, defined from one more more sources, and which can have
    dependencies on other assets.
    
    Parameters:
        name (str): the asset name, e.g. 'foo.js' or 'bar.css'. Can contain
            slashes to emulate a file system. e.g. 'spam/foo.js'.
        sources (str, list): the sources to generate this asset from.
            Can be strings with source code, string uri's, ``Model``
            subclasses, and (for JS) any PyScript compatible class or function.
        deps (list): names of assets that this asset depends on, used to
            resolve the load order. For module assets one can use
            'foo.js as foo' to define the name by which the dependency can be
            accessed inside the module.
        exports (list, str, optional): Should not be given for CSS. If given
            for JS (and not None) the asset is wrapped in an AMD module that
            exports the given name/names. Note that providing an empty list
            is interpreted as "make a module without exported names".
    
    *Remote assets*
    
    If only one source is provided and its a uri (starting with
    'http://', 'https://' or 'file://') this is considered a remote asset,
    i.e. the client will obtain the source from elsewhere. Exported apps
    will include the asset though. In case a uri is given together with
    other sources, Flexx will (down)load the code to include it in the asset.
    
    """
    def __init__(self, name=None, sources=None, deps=None, exports=None):
        
        # if no_args:
        #     raise ValueError('For reasons of clarity, assets must be defined '
        #                      'using keyword arguments: name, sources, deps, exports.')
        
        # Handle name
        if name is None:
            raise ValueError('Assets name must be given (str).')
        if not isinstance(name, str):
            raise ValueError('Asset name must be str.')
        if not name.lower().endswith(('.js', '.css')):
            raise ValueError('Asset is only for .js and .css assets.')
        self._name = name
        isjs = name.lower().endswith('.js')
        
        # Handle sources
        if sources is None:
            sources = []  #raise ValueError('Assets sources must be given (str or list).')
        if isinstance(sources, str):
            sources = [sources]
        if not isinstance(sources, (tuple, list)):
            raise ValueError('Asset sources must be str/tuple/list.')
        for source in sources:
            if not (isinstance(source, str) or
                    (isinstance(source, type) and issubclass(source, Model)) or
                    (isjs and callable(source))):
                raise ValueError('Asset %r cannot convert source %r to CSS.' %
                                 (name, source, name.split('.')[0].upper()))
        self._sources = list(sources)
        
        # Remote source?
        self._is_remote = False
        uri_starts = 'http://', 'https://', 'file://'
        if len(self._sources) == 0 and name.startswith(uri_starts):
            self._sources = [name]  # todo: will this work with exported apps?
        if len(self._sources) == 0:
            raise ValueError('An asset cannot be without sources.')
        if (len(self._sources) == 1 and isinstance(self._sources[0], str)
                                    and self._sources[0].startswith(uri_starts)):
            self._is_remote = True
        
        # Handle deps
        if deps is None and self._is_remote:
            deps = []
        if deps is None:
            raise ValueError('Assets deps must be given, '
                             'use empty list if it has no dependencies.')
        if not isinstance(deps, (tuple, list)):
            raise ValueError('Asset deps must be a tuple/list.')
        if not all(isinstance(dep, str) for dep in deps):
            raise ValueError('Asset deps\' elements must be str.')
        # Handler "as" in deps
        self._deps = [d.split(' as ')[0] for d in deps]
        self._imports = [d for d in deps if ' as ' in d]
        
        # Handle exports
        self._need_pyscript_std = False
        if not isjs:
            if exports is not None:
                raise ValueError('Assets exports must *not* be given for CSS assets.')
            exports = None
        if exports is None:
            self._exports = None
        elif isinstance(exports, str):
            self._exports = str(exports)
        elif isinstance(exports, (tuple, list)):
            if not all(isinstance(export, str) for export in exports):
                raise ValueError('Asset exports\' elements must be str.')
            self._exports = list(exports)
        else:
            raise ValueError('Asset exports must be a None or list.')
        
        # Cache -> total code is generated just once
        self._cache = None
        if not self._is_remote:
            self.to_string()  # Generate code now
    
    def __repr__(self):
        return '<%s %r at 0x%0x>' % (self.__class__.__name__, self._name, id(self))
        
    @property
    def name(self):
        """ The (file) name of this asset.
        """
        return self._name
    
    @property
    def is_remote(self):
        """ Whether the asset is remote (client will load it from elsewhere).
        """
        return self._is_remote
    
    @property
    def is_module(self):
        """ Whether this asset is wrapped inside an AMD JS module.
        """
        return self._exports is not None
    
    @property
    def deps(self):
        """ The list of dependencies for this JS/CSS asset.
        """
        return tuple(self._deps)
    
    @property
    def sources(self):
        """ The list of sources. Each source can be:
        
        * A string of JS/CSS code.
        * A filename or uri (start with "file://", "http://" or "https://"):
          the code is (down)loaded on the server. 
        * A subclass of ``Model``: the corresponding JS/CSS is extracted.
        * Any other Python function ot class: JS is generated via PyScript.
        """
        return tuple(self._sources)
    
    @property
    def exports(self):
        """ List of names that this JS module should export. Is
        auto-populated with the names of classes provided in the
        code list.
        """
        return tuple(self._exports)

    def to_html(self, link='{}'):
        """ Get HTML element tag to include in the document. The link
        argument is formatted with the asset name. If link evaluates to False,
        the asset is embedded rather than linked.
        """
        if self._name.startswith('embed:'):
            link = False  # Undocumented feature used internally
        
        if self.name.lower().endswith('.js'):
            if not link:
                return '<script>' + self.to_string() + '</script>'
            elif self._is_remote:
                return "<script src=%r></script>" % self._sources[0]
            else:
                return "<script src='%s'></script>" % link.format(self.name)
        elif self.name.lower().endswith('.css'):
            if not link:
                return '<style>' + self.to_string() + '</style>'
            elif self._is_remote:
                url = self._sources[0]
                return "<link rel='stylesheet' type='text/css' href=%r />" % url
            else:
                t = "<link rel='stylesheet' type='text/css' href='%s' />"
                return t % link.format(self.name)
        else:  # pragma: no cover
            raise NameError('Assets must be .js or .css')
    
    def to_string(self):
        """ Get the string code provided by this asset. This is what
        gets served to the client.
        """
        if self._cache is None:
            if self.is_module:
                # Create JS module, but also take care of inserting PyScript std.
                lib = 'pyscript-std.js'
                code, names = self._get_code_and_names()
                if self._need_pyscript_std and lib not in self._imports:
                    self._imports.append(lib)
                if lib in self._imports:
                    self._imports[self._imports.index(lib)] = lib + ' as _py'
                    func_names, method_names = get_all_std_names()
                    pre1 = ', '.join(['%s = _py.%s' % (n, n) for n in func_names])
                    pre2 = ', '.join(['%s = _py.%s' % (n, n) for n in method_names])
                    code.insert(0, 'var %s;\nvar %s;' % (pre1, pre2))
                self._cache = create_js_module(self.name, '\n\n'.join(code), 
                                            self._imports, self._exports, 'amd')
            else:
                code, names = self._get_code_and_names()
                self._cache = '\n\n'.join(code)
            if self._need_pyscript_std:
                self._cache = HEADER + '\n\n' + self._cache  # Add license header
        return self._cache
    
    def _get_code_and_names(self):
        code = []
        names = []
        for ob in self.sources:
            c, name = self._convert_to_code(ob)
            if c:
                code.append(c)
                if name:
                    names.append(name)
        if not (len(code) == 1 and not '\n' in code[0]):
            code.append('')
        return code, names
    
    def _convert_to_code(self, ob):
        """ Convert object to JS/CSS.
        """
        isjs = self.name.lower().endswith('.js')
        name = None
        
        if isinstance(ob, str):
            c = self._handle_uri(ob)
        elif isinstance(ob, type) and issubclass(ob, Model):
            name = ob.__name__
            c = ob.JS.CODE if isjs else ob.CSS
            self._need_pyscript_std = True
        elif isjs and callable(ob):
            try:
                c = py2js(ob)
                self._need_pyscript_std = True
            except Exception as err:
                raise ValueError('Asset %r cannot convert %r to JS:\n%s' %
                                 (self.name, ob, str(err)))
            name = ob.__name__
        else:
            raise ValueError('Asset %r cannot convert object %r to CSS.' %
                             (ob, self.name.split('.')[0].upper()))
        return c.strip(), name
    
    def _handle_uri(self, s):
        if s.startswith(('http://', 'https://')):
            return urlopen(s, timeout=5.0).read().decode()
        elif s.startswith('file://'):
            return open(s.split('//', 1)[1], 'rb').read().decode()
        else:
            return s


class AssetStore:
    """ Global provider of client assets (CSS, JavaScript, images, etc.).
    
    Assets are global to the process via the AssetStore instance at
    ``flexx.app.assets``. An asset must be "used" at each ``Session``
    instance where it ought to be loaded. The session can also be used
    to load unique (per session, name mangled) assets.
    """
    
    def __init__(self):
        self._assets = OrderedDict()
        self._data = {}
        self.add_shared_asset(Asset('reset.css', RESET, []))
        # todo: wrap loader code in a module, but not a define/AMD one, just function () {..}()
        # todo: --> support multiple loaders, AMD / UMD constructs
        self.add_shared_asset(Asset('flexx-loader.js', LOADER, [], None))
        
        from ..pyscript.stdlib import get_full_std_lib, get_all_std_names
        func_names, method_names = get_all_std_names()
        self.add_shared_asset(Asset('pyscript-std.js', get_full_std_lib(),
                                    [], func_names + method_names))
    
    def __repr__(self):
        names1 = ', '.join([repr(name) for name in self._assets])
        names2 = ', '.join([repr(name) for name in self._data])
        return '<AssetStore with assets: %s, and data %s>' % (names1, names2)
    
    def get_asset(self, name):
        """ Get the asset instance corresponding to the given name or None
        if it not known.
        """
        if not name.lower().endswith(('.js', '.css')):
            raise ValueError('Asset names always end in .js or .css')
        return self._assets.get(name, None)
    
    def get_data(self, name):
        """ Get the data (as bytes) corresponding to the given name or None
        if it not known.
        """
        return self._data.get(name, None)
    
    def get_asset_names(self):
        """ Get a list of all asset names.
        """
        return list(self._assets.keys())
    
    def get_data_names(self):
        """ Get a list of all data names.
        """
        return list(self._data.keys())
    
    def add_shared_data(self, name, data):
        """ Add data to serve to the client (e.g. images), which is shared
        between sessions. It is an error to add data with a name that
        is already registered. Returns the link at which the data can
        be retrieved. See ``Session.add_data()`` to set data per-session.
        
        Parameters:
            name (str): the name of the data, e.g. 'icon.png'. 
            data (bytes): the data blob. Can also be a uri to the blob
                (string starting with "file://", "http://" or "https://").
          the code is (down)loaded on the server.
        """
        if not isinstance(name, str):
            raise ValueError('add_shared_data() name must be a str.')
        if name in self._data:
            raise ValueError('add_shared_data() got existing name %r.' % name)
        if isinstance(data, str):
            if data.startswith('file://'):
                data = open(data.split('//', 1)[1], 'rb').read()
            elif data.startswith(('http://', 'https://')):
                data = urlopen(data, timeout=5.0).read()
        if not isinstance(data, bytes):
            raise ValueError('add_shared_data() data must be bytes.')
        self._data[name] = data
        return '/_data/shared/%s' % name
    
    def add_shared_asset(self, asset=None, **kwargs):
        """ Add a JS/CSS asset to share between sessions. It is an error
        to add an asset with a name that is already registered. See
        ``Session.add_asset()`` to set assets per-session.
        
        The asset should be given either as an asset instance, or as keyword
        arguments to create an ``Asset``.
        See :class:`Asset class <flexx.app.Asset>` for details.
        """
        if kwargs and asset is not None:
            raise ValueError('add_shared_asset() needs either asset or kwargs.')
        elif asset is not None:
            if not isinstance(asset, Asset):
                raise ValueError('add_shared_asset() asset arg must be an Asset.')
            if asset.name in self._assets:
                raise ValueError('add_shared_asset() %r is already set.' % asset.name)
            self._assets[asset.name] = asset
        elif kwargs:
            self.add_shared_asset(Asset(**kwargs))
        else:
            raise ValueError('add_shared_asset() needs asset or kwargs.')
    
    def get_asset_for_class(self, cls):
        """ Get the asset that provides the given Python class.
        """
        for asset in self._assets.values():
            if cls in asset.sources:
                return asset
        return None
    
    def get_module_classes(self, module_name):
        """ Get the Model classes corrsesponding to the given module name
        and that are not already provided by an asset.
        """
        # Get classes
        classes = list()
        for cls in get_model_classes():
            if modname_startswith(cls.__module__, module_name):
                if self.get_asset_for_class(cls) is None:
                    classes.append(cls)
        return classes
    
    # todo: test this
    def export(self, dirname):
        """ Write all assets to the given directory.
        """
        # Normalize and check
        if dirname.startswith('~'):  # pragma: no cover
            dirname = os.path.expanduser(dirname)
        if not os.path.isdir(dirname):
            raise ValueError('dirname %r for export is not a directory.' % dirname)
        # Export all assets
        for fname in self.get_asset_names():
            if not fname.startswith('index-'):
                with open(os.path.join(dirname, fname), 'wb') as f:
                    f.write(self.get_asset(fname).tobytes())

# Our singleton asset store
assets = AssetStore()


class SessionAssets:
    """ Provider for assets for a specific session. Inherited by Session.
    
    Assets included on the document consist of the page assets
    registered on the session, plus the (global) page assets that these
    depend on.
    """
    
    def __init__(self, store=None):  # Allow custom store for testing
        self._store = store if (store is not None) else assets
        assert isinstance(self._store, AssetStore)
        
        self._id = get_random_string()
        self._app_name = ''
        
        # Keep track of all assets for this session. Assets that are provided
        # by the asset store have a value of None.
        self._assets = OrderedDict()
        # Data for this session (in addition to the data provided by the store)
        self._data = {}
        # Whether the page has been served already
        self._served = False
        # Cache what classes we know (for performance)
        self._known_classes = set()
        # Model classes that are not in an asset/module
        self._extra_model_classes = []
    
    @property
    def id(self):
        """ The unique identifier of this session.
        """
        return self._id
    
    def get_asset_names(self):
        """ Get a list of names of the assets used by this session, in
        the order that they were added.
        """
        return list(self._assets.keys())  # Note: order matters
    
    def get_data_names(self):
        """ Get a list of names of the data provided by this session, in
        the order that they were added.
        """
        return list(self._data.keys())  # Note: order matters
    
    def _inject_asset_dynamically(self, asset):
        """ Load an asset in a running session.
        """
        logger.debug('Dynamically loading asset %r' % asset.name)
        
        # In notebook?
        from .session import manager  # noqa - avoid circular import
        is_interactive = self is manager.get_default_session()  # e.g. in notebook
        in_notebook = is_interactive and getattr(self, 'init_notebook_done', False)
        
        if in_notebook:
            # Load using IPython constructs
            from IPython.display import display, HTML
            if asset.name.lower().endswith('.js'):
                display(HTML("<script>%s</script>" % asset.to_string()))
            else:
                display(HTML("<style>%s</style>" % asset.to_string()))
        else:
            # Load using Flexx construct
            suffix = asset.name.split('.')[-1].upper()
            self._send_command('DEFINE-%s %s' % (suffix, asset.to_string()))
    
    def get_asset(self, name):
        """ Get the asset corresponding to the given name. This can be
        an asset local to the session, or a global asset that this session
        is using. Returns None if asset by that name is unknown.
        """
        if not name.lower().endswith(('.js', '.css')):
            raise ValueError('Asset names always end in .js or .css')
        asset = self._assets.get(name, None)
        if asset is None:
            asset = self._store.get_asset(name)
        return asset
    
    def get_data(self, name):
        """ Get the data corresponding to the given name. This can be
        data local to the session, or global data. Returns None if data
        by that name is unknown.
        """
        data = self._data.get(name, None)
        if data is None:
            data = self._store.get_data(name)
        return data
    
    def add_asset(self, asset=None, **kwargs):  # -> asset must already exist
        """ Use the given JS/CSS asset in this session. It is safe to
        call this method with an already registered asset. See
        ``app.assets.add_shared_asset()`` to define shared assets.
        
        The asset should be given either as an asset instance, the name of
        an asset in the asset store, or as keyword arguments to create
        an ``Asset``. See :class:`Asset class <flexx.app.Asset>` for details.
        """
        if kwargs and asset is not None:
            raise ValueError('Session.add_asset() needs either asset or kwargs.')
        elif asset is not None:
            # Get the actual asset instance
            if isinstance(asset, str):
                asset = self._store.get_asset(asset)
                if asset is None:
                    raise ValueError('Session.add_asset() got unknown asset name.')
            elif not isinstance(asset, Asset):
                raise ValueError('Session.add_asset() needs str, Asset or kwargs.')
            self._register_asset(asset)
        elif kwargs:
            self.add_asset(Asset(**kwargs))
        else:
            raise ValueError('Session.add_asset() needs asset or kwargs.')
    
    def _register_asset(self, asset):
        # Register or load asset, if necessary
        if asset.name in self._assets:
            cur_asset = self._assets[asset.name]
            if not (cur_asset is None or cur_asset is asset):
                raise ValueError('Cannot register asset under an existing asset name.')
        elif self._served:
            self._inject_asset_dynamically(asset)
        elif asset is self._store.get_asset(asset.name):
            self._assets[asset.name] = None  # None means that asset is global
        else:
            self._assets[asset.name] = asset
    
    def add_data(self, name, data):  # todo: add option to clear data after its loaded?
        """ Add data to serve to the client (e.g. images), specific to this
        session. Returns the link at which the data can be retrieved.
        See ``app.assets.add_shared_data()`` to provide shared data.
        
        Parameters:
            name (str): the name of the data, e.g. 'icon.png'. If data has
                already been set on this name, it is overwritten.
            data (bytes): the data blob. Can also be a uri to the blob
                (string starting with "file://", "http://" or "https://").
        """
        if not isinstance(name, str):
            raise ValueError('Session.add_data() name must be a str.')
        if name in self._data:
            raise ValueError('Session.add_data() got existing name %r.' % name)
        if isinstance(data, str):
            if data.startswith('file://'):
                data = open(data.split('//', 1)[1], 'rb').read()
            elif data.startswith(('http://', 'https://')):
                data = urlopen(data, timeout=5.0).read()
        if not isinstance(data, bytes):
            raise ValueError('Session.add_data() data must be a bytes.')
        self._data[name] = data
        return '/_data/%s/%s' % (self.id, name)
    
    def register_model_class(self, cls):
        """ Ensure that the client knows the given class. A class can
        already be defined via a module asset, or we can add it to a
        pending list if the page has not been served yet. Otherwise it
        needs to be defined dynamically.
        """
        if not (isinstance(cls, type) and issubclass(cls, Model)):
            raise ValueError('Not a Model class')
        
        # Early exit if we know the class already
        if cls in self._known_classes:
            return
        
        # Make sure the base classes are registered first
        for cls2 in cls.mro()[1:]:
            if not issubclass(cls2, Model):  # True if cls2 is *the* Model class
                break
            if cls2 not in self._known_classes:
                self.register_model_class(cls2)
        
        # Make sure that no two models have the same name, or we get problems
        # that are difficult to debug. Unless classes are defined in the notebook.
        same_name = [c for c in self._known_classes if c.__name__ == cls.__name__]
        if same_name:
            from .session import manager  # noqa - avoid circular import
            same_name.append(cls)
            is_interactive = self is manager.get_default_session()  # e.g. in notebook
            is_dynamic_cls = not any([self._store.get_asset_for_class(c)
                                      for c in same_name])
            if not (is_interactive and is_dynamic_cls):
                raise RuntimeError('Cannot have multiple Model classes with the same '
                                   'name unless using interactive session and the '
                                   'classes are dynamically defined: %r' % same_name)
        
        logger.debug('Registering Model class %r' % cls.__name__)
        self._known_classes.add(cls)
        
        # Check if cls is covered by our assets
        asset_js = self._store.get_asset_for_class(cls)
        asset_css = None
        if asset_js:
            asset_css = self._store.get_asset(asset_js.name[:-2] + 'css')
        
        if asset_js:
            # cls is present in a module, add corresponding asset (overwrite ok)
            for asset in [asset_js, asset_css]:
                if asset and asset.name not in self._assets:
                    if self._served:
                        self._inject_asset_dynamically(asset)
                    else:
                        self._assets[asset.name] = None
        elif not self._served:
            # Remember cls, will be served in the index
            self._extra_model_classes.append(cls)
        else:
            # Define class dynamically - assuming we're a session subclass ...
            for asset in [Asset(cls.__name__ + '.js', [], cls.JS.CODE), 
                          Asset(cls.__name__ + '.css', [], cls.CSS)]:
                if asset.sources[0].strip():
                    self._inject_asset_dynamically(asset)
    
    def get_assets_in_order(self, css_reset=False):
        """ Get two lists containing the JS assets and CSS assets,
        respectively. The assets contain all assets in use and their
        dependencies. The order is based on the dependency resolution
        and the order in which assets were registered via
        ``add_asset()``. Special assets are added, such as the CSS reset,
        the JS loader, and CSS and JS for classes not defined in a module.
        """
        # todo: test incorrect order; loader should be able to handle it for JS
        # todo: put remote assets with no deps at the end
        
        def collect_dependencies(asset, asset_dict):
            for dep in asset.deps:
                if dep in asset_dict:
                    pass  # already in list
                elif dep in self._store._assets:
                    a = self._store._assets[dep]
                    asset_dict[a.name] = a
                    collect_dependencies(a, asset_dict)
                else:
                    unknown_deps.append(dep)
                    logger.warn('Asset %r has unfulfilled dependency %r' %
                                (asset.name, dep))
        
        def flatten_tree(asset_list, asset_dict):
            for index in range(len(asset_list)):
                seen_names = []
                cur_asset_list = asset_list.copy()
                while True:
                    # Get asset name on this position, check if its new
                    name = asset_list[index]
                    if name in seen_names:
                        raise RuntimeError('Detected circular dependency in assets!')
                    seen_names.append(name)
                    # Move deps in front of us if necessary
                    for dep in asset_dict[name].deps:
                        if dep not in unknown_deps:
                            j = asset_list.index(dep)
                            if j > index:
                                asset_list.insert(index, asset_list.pop(j))
                                break  # do this index again; the dep we just moved
                    else:
                        break  # no changes, move to next index
        
        # Append code for extra classes
        if self._extra_model_classes and 'extra-classes.js' not in self._assets:
            self.add_asset(Asset('extra-classes.js', self._extra_model_classes,
                                 deps=[], exports=[]))
            self.add_asset(Asset('extra-classes.css', self._extra_model_classes, []))
        
        # Collect initial assets for this session
        js_assets, css_assets = OrderedDict(), OrderedDict()
        for name in self._assets.keys():
            asset = self.get_asset(name)
            if asset.name.lower().endswith('.js'):
                js_assets[asset.name] = asset
            else:
                css_assets[asset.name] = asset
        
        # Collect dependencies so that we have all assets that matter
        unknown_deps = []
        for asset in list(js_assets.values()):
            collect_dependencies(asset, js_assets)
        for asset in list(css_assets.values()):
            collect_dependencies(asset, css_assets)
        
        # Flatten the trees into flat lists
        js_assets2 = list(js_assets.keys())
        flatten_tree(js_assets2, js_assets)
        css_assets2 = list(css_assets.keys())
        flatten_tree(css_assets2, css_assets)
        js_assets = [js_assets[name] for name in js_assets2]
        css_assets = [css_assets[name] for name in css_assets2]
        
        # Prepend reset.css
        if css_reset:
            css_assets.insert(0, self.get_asset('reset.css'))
        
        # Prepend loader
        js_assets.insert(0, self.get_asset('flexx-loader.js'))
        t = 'var flexx = {app_name: "%s", session_id: "%s"};' % (self._app_name, self.id)
        js_assets.insert(0, Asset('embed:flexx-init.js', t, []))
        
        # todo: set served!
        return js_assets, css_assets
    
    def get_page(self, single=False):
        """ Get the string for the HTML page to render this session's app.
        """
        js_assets, css_assets = self.get_assets_in_order(True)
        return self._get_page(js_assets, css_assets, single)
    
    def get_page_for_export(self, commands, single=False):
        """ Get the string for an exported HTML page (to run without a server).
        """
        # Create lines to init app
        lines = []
        lines.append('flexx.is_exported = true;\n')  # todo: use session_id = 'exported'?
        lines.append('flexx.runExportedApp = function () {')
        lines.extend(['    flexx.command(%s);' % reprs(c) for c in commands])
        lines.append('};\n')
        # Compose - make it use a dummy session id
        id, self._id = self._id, 'exported'
        js_assets, css_assets = self.get_assets_in_order(True)
        self._id = id
        js_assets.append(Asset('flexx-export.js', [], '\n'.join(lines)))
        return self._get_page(js_assets, css_assets, single)
    
    def _get_page(self, js_assets, css_assets, single):
        """ Compose index page.
        """
        codes = []
        for assets in [css_assets, js_assets]:
            for asset in assets:
                link = '/_assets/shared/{}'
                if self._store.get_asset(asset.name) is not asset:
                    link = '/_assets/%s/{}' % self.id
                codes.append(asset.to_html(link))
            codes.append('')
        
        src = INDEX
        if single:
            src = src.replace('ASSET-LINK-HOOK', '')
            src = src.replace('ASSET-CONTENT-HOOK', '\n'.join(codes))
        else:
            codes = ['    ' + code for code in codes]
            src = src.replace('ASSET-LINK-HOOK', '\n'.join(codes))
            src = src.replace('ASSET-CONTENT-HOOK', '')
        
        return src
